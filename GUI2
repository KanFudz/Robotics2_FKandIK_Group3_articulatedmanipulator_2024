import tkinter as tk
from tkinter import messagebox, PhotoImage
import numpy as np

# Importing DHRobot and RevoluteDH classes from the appropriate library
from roboticstoolbox import DHRobot, RevoluteDH

# Custom color palette
color_palette = {
    'bg1': '#10232A',
    'bg2': '#3D4D55',
    'bg3': '#A79E9C',
    'bg4': '#D3C3B9',
    'bg5': '#B58863',
    'bg6': '#20212B',
    'entry_bg': '#E9C46A',
}

# Function to reset entry fields
def reset():
    for entry in (a1_E, a2_E, a3_E, T1_E, T2_E, T3_E, X_E, Y_E, Z_E):
        entry.delete(0, tk.END)

# Function for forward kinematics
def f_k():
    a1 = float(a1_E.get())/100
    a2 = float(a2_E.get())/100
    a3 = float(a3_E.get())/100
    T1 = float(T1_E.get())
    T2 = float(T2_E.get())
    T3 = float(T3_E.get())
    T1 = (T1/180.0)*np.pi
    T2 = (T2/180.0)*np.pi
    T3 = (T3/180.0)*np.pi
    PT = [[T1, (90.0/180.0)*np.pi, 0, a1],
          [T2, (0.0/180.0)*np.pi, a2, 0],
          [T3, (0.0/180.0)*np.pi, a3, 0]]
    H0_1 = np.array([[np.cos(PT[0][0]), -np.sin(PT[0][0])*np.cos(PT[0][1]), np.sin(PT[0][0])*np.sin(PT[0][1]), PT[0][2]*np.cos(PT[0][0])],
                      [np.sin(PT[0][0]), np.cos(PT[0][0])*np.cos(PT[0][1]), -np.cos(PT[0][0])*np.sin(PT[0][1]), PT[0][2]*np.sin(PT[0][0])],
                      [0, np.sin(PT[0][1]), np.cos(PT[0][1]), PT[0][3]],
                      [0, 0, 0, 1]])
    H1_2 = np.array([[np.cos(PT[1][0]), -np.sin(PT[1][0])*np.cos(PT[1][1]), np.sin(PT[1][0])*np.sin(PT[1][1]), PT[1][2]*np.cos(PT[1][0])],
                      [np.sin(PT[1][0]), np.cos(PT[1][0])*np.cos(PT[1][1]), -np.cos(PT[1][0])*np.sin(PT[1][1]), PT[1][2]*np.sin(PT[1][0])],
                      [0, np.sin(PT[1][1]), np.cos(PT[1][1]), PT[1][3]],
                      [0, 0, 0, 1]])
    H2_3 = np.array([[np.cos(PT[2][0]), -np.sin(PT[2][0])*np.cos(PT[2][1]), np.sin(PT[2][0])*np.sin(PT[2][1]), PT[2][2]*np.cos(PT[2][0])],
                      [np.sin(PT[2][0]), np.cos(PT[2][0])*np.cos(PT[2][1]), -np.cos(PT[2][0])*np.sin(PT[2][1]), PT[2][2]*np.sin(PT[2][0])],
                      [0, np.sin(PT[2][1]), np.cos(PT[2][1]), PT[2][3]],
                      [0, 0, 0, 1]])
    H0_2 = np.dot(H0_1, H1_2)
    H0_3 = np.dot(H0_2, H2_3)
    X0_3 = H0_3[0, 3]
    X_E.delete(0, tk.END)
    X_E.insert(0, np.around(X0_3*100, 3))
    Y0_3 = H0_3[1, 3]
    Y_E.delete(0, tk.END)
    Y_E.insert(0, np.around(Y0_3*100, 3))
    Z0_3 = H0_3[2, 3]
    Z_E.delete(0, tk.END)
    Z_E.insert(0, np.around(Z0_3*100, 3))

# Function for inverse kinematics
def i_k():
    a1 = float(a1_E.get())
    a2 = float(a2_E.get())
    a3 = float(a3_E.get())
    x0_3 = float(X_E.get())
    y0_3 = float(Y_E.get())
    z0_3 = float(Z_E.get())
    if x0_3 == 0:
        theta1 = np.pi/2 if y0_3 > 0 else -np.pi/2
    else:
        theta1 = np.arctan(y0_3/x0_3)
    r1 = np.sqrt(y0_3**2 + x0_3**2)
    r2 = z0_3-a1
    if r1 == 0:
        phi1 = np.pi/2 if r2 > 0 else - np.pi/2
    else:
        phi1 = np.arctan(r2/r1)
    r3 = np.sqrt(r2**2+r1**2)
    phi2 = np.arccos(np.clip((a3**2-a2**2-r3**2)/(-2*a2*r3), -1, 1))
    theta2 = phi1+phi2
    phi3 = np.arccos(np.clip((r3**2-a2**2-a3**2)/(-2*a2*a3), -1, 1))
    theta3 = phi3-np.pi
    T1_E.delete(0, tk.END)
    T1_E.insert(0, np.around(theta1*180/np.pi, 3))
    T2_E.delete(0, tk.END)
    T2_E.insert(0, np.around(theta2*180/np.pi, 3))
    T3_E.delete(0, tk.END)
    T3_E.insert(0, np.around(theta3*180/np.pi, 3))

# Function to create the link length and joint variables frame
def create_link_length_and_joint_variables_frame():
    FI = tk.LabelFrame(mygui, text='Link Lengths and Joint Variables', font=(5), bg='#F4A261')
    FI.grid(row=0, column=0)

    a1 = tk.Label(FI, text='a1=', font=(5), bg='#2A9D8F')
    global a1_E
    a1_E = tk.Entry(FI, width=5, font=(5), bg='#E9C46A')
    cm1 = tk.Label(FI, text='cm', font=(5), bg='#2A9D8F')

    a2 = tk.Label(FI, text='a2=', font=(5), bg='#2A9D8F')
    global a2_E
    a2_E = tk.Entry(FI, width=5, font=(5), bg='#E9C46A')
    cm2 = tk.Label(FI, text='cm', font=(5), bg='#2A9D8F')

    a3 = tk.Label(FI, text='a3=', font=(5), bg='#2A9D8F')
    global a3_E
    a3_E = tk.Entry(FI, width=5, font=(5), bg='#E9C46A')
    cm3 = tk.Label(FI, text='cm', font=(5), bg='#2A9D8F')

    a1.grid(row=0, column=0)
    a1_E.grid(row=0, column=1)
    cm1.grid(row=0, column=2)

    a2.grid(row=1, column=0)
    a2_E.grid(row=1, column=1)
    cm2.grid(row=1, column=2)

    a3.grid(row=2, column=0)
    a3_E.grid(row=2, column=1)
    cm3.grid(row=2, column=2)

    T1 = tk.Label(FI, text='T1 = ', font=(5), bg='#2A9D8F')
    global T1_E
    T1_E = tk.Entry(FI, width=5, font=(5), bg='#E9C46A')
    deg1 = tk.Label(FI, text='deg', font=(5), bg='#2A9D8F')

    T2 = tk.Label(FI, text='T2 = ', font=(5), bg='#2A9D8F')
    global T2_E
    T2_E = tk.Entry(FI, width=5, font=(5), bg='#E9C46A')
    deg2 = tk.Label(FI, text='deg', font=(5), bg='#2A9D8F')

    T3 = tk.Label(FI, text='T3 = ', font=(5), bg='#2A9D8F')
    global T3_E
    T3_E = tk.Entry(FI, width=5, font=(5), bg='#E9C46A')
    deg3 = tk.Label(FI, text='deg', font=(5), bg='#2A9D8F')

    T1.grid(row=0, column=3)
    T1_E.grid(row=0, column=4)
    deg1.grid(row=0, column=5)

    T2.grid(row=1, column=3)
    T2_E.grid(row=1, column=4)
    deg2.grid(row=1, column=5)

    T3.grid(row=2, column=3)
    T3_E.grid(row=2, column=4)
    deg3.grid(row=2, column=5)

# Function to create the buttons frame
def create_buttons_frame():
    BF = tk.LabelFrame(mygui, text='Forward Kinematics', font=(5))
    BF.grid(row=1, column=0)

    FK = tk.Button(BF, text='Forward', font=(5), bg='blue', fg='white', command=f_k)
    rst = tk.Button(BF, text='Reset', font=(5), bg='red', fg='white', command=reset)
    IK = tk.Button(BF, text='Inverse', font=(5), bg='green', fg='white', command=i_k)

    FK.grid(row=0, column=0)
    rst.grid(row=0, column=1)
    IK.grid(row=0, column=2)

# Function to create the position vectors frame
def create_position_vectors_frame():
    PV = tk.LabelFrame(mygui, text='Position Vector', font=(5))
    PV.grid(row=2, column=0)

    X = tk.Label(PV, text='X = ', font=(5), bg='#2A9D8F')
    global X_E
    X_E = tk.Entry(PV, width=5, font=(5))
    cm4 = tk.Label(PV, text='cm', font=(5), bg='#2A9D8F')

    Y = tk.Label(PV, text='Y = ', font=(5), bg='#2A9D8F')
    global Y_E
    Y_E = tk.Entry(PV, width=5, font=(5))
    cm5 = tk.Label(PV, text='cm', font=(5), bg='#2A9D8F')

    Z = tk.Label(PV, text='Z = ', font=(5), bg='#2A9D8F')
    global Z_E
    Z_E = tk.Entry(PV, width=5, font=(5))
    cm6 = tk.Label(PV, text='cm', font=(5), bg='#2A9D8F')

    X.grid(row=0, column=0)
    X_E.grid(row=0, column=1)
    cm4.grid(row=0, column=2)

    Y.grid(row=1, column=0)
    Y_E.grid(row=1, column=1)
    cm5.grid(row=1, column=2)

    Z.grid(row=2, column=0)
    Z_E.grid(row=2, column=1)
    cm6.grid(row=2, column=2)

# Function to insert the image
def insert_image():
    img = PhotoImage(file='arti.png')
    img = img.subsample(3, 3)
    PI = tk.Label(mygui, image=img)
    PI.grid(row=3, column=0)

# Create GUI Window with title
mygui = tk.Tk()
mygui.title('Articulated Calculator')
mygui.resizable(False, False)
mygui.configure(bg=color_palette['bg1'])

# Create Frames
create_link_length_and_joint_variables_frame()
create_buttons_frame()
create_position_vectors_frame()

# Insert image
insert_image()

# Mainloop
mygui.mainloop()
