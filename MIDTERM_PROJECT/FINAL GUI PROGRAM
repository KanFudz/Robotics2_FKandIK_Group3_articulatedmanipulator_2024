from tkinter import *
from tkinter import messagebox
from tkinter import PhotoImage
import numpy as np
import matplotlib as mpl
mpl.use('TkAgg')
import roboticstoolbox as rtb
from roboticstoolbox import DHRobot, RevoluteDH, PrismaticDH

# Create GUI Window with title
root = Tk()
root.title('Articulated Calculator')
root.resizable(False, False)
root.configure(bg='black')

def Forward_Kinematics():
    global a1_entry, a2_entry, a3_entry, T1_entry, T2_entry, T3_entry, X_output, Y_output, Z_output

    # Create entry fields for link lengths
    a1_label = Label(root, text="a1:", padx=5, pady=5, bg='#012228', fg='white')
    a1_label.grid(row=1, column=0, sticky=W)
    a1_entry = Entry(root, width=10)
    a1_entry.grid(row=1, column=1, padx=5, pady=5)

    a2_label = Label(root, text="a2:", padx=5, pady=5, bg='#032b28', fg='white')
    a2_label.grid(row=2, column=0, sticky=W)
    a2_entry = Entry(root, width=10)
    a2_entry.grid(row=2, column=1, padx=5, pady=5)

    a3_label = Label(root, text="a3:", padx=5, pady=5, bg='#0d3f2e', fg='white')
    a3_label.grid(row=3, column=0, sticky=W)
    a3_entry = Entry(root, width=10)
    a3_entry.grid(row=3, column=1, padx=5, pady=5)

    # Create entry fields for joint variables
    T1_label = Label(root, text="T1:", padx=5, pady=5, bg='#1f563e', fg='white')
    T1_label.grid(row=4, column=0, sticky=W)
    T1_entry = Entry(root, width=10)
    T1_entry.grid(row=4, column=1, padx=5, pady=5)

    T2_label = Label(root, text="T2:", padx=5, pady=5, bg='#136345', fg='white')
    T2_label.grid(row=5, column=0, sticky=W)
    T2_entry = Entry(root, width=10)
    T2_entry.grid(row=5, column=1, padx=5, pady=5)

    T3_label = Label(root, text="T3:", padx=5, pady=5, bg='#117955', fg='white')
    T3_label.grid(row=6, column=0, sticky=W)
    T3_entry = Entry(root, width=10)
    T3_entry.grid(row=6, column=1, padx=5, pady=5)

    # Create output fields for position vector components
    X_label = Label(root, text="X:", padx=5, pady=5, bg='#3e8e6f')
    X_label.grid(row=7, column=0, sticky=W)
    X_output = Entry(root, width=10, state='readonly')
    X_output.grid(row=7, column=1, padx=5, pady=5)

    Y_label = Label(root, text="Y:", padx=5, pady=5, bg='#539d85')
    Y_label.grid(row=8, column=0, sticky=W)
    Y_output = Entry(root, width=10, state='readonly')
    Y_output.grid(row=8, column=1, padx=5, pady=5)

    Z_label = Label(root, text="Z:", padx=5, pady=5, bg='#65ae91')
    Z_label.grid(row=9, column=0, sticky=W)
    Z_output = Entry(root, width=10, state='readonly')
    Z_output.grid(row=9, column=1, padx=5, pady=5)

    # Create two buttons
    calculate_btn = Button(root, text="Calculate", command=calculate_forward)
    calculate_btn.grid(row=10, column=0, padx=5, pady=5)

    reset_btn = Button(root, text="Reset", bg='#AE2012', command=reset_field1)
    reset_btn.grid(row=10, column=1, padx=5, pady=5)


def Inverse_Kinematics():
    global a1_entry_inv, a2_entry_inv, a3_entry_inv, X_entry, Y_entry, Z_entry, T1_output, T2_output, T3_output

    # Create entry fields for link lengths
    a1_label_inv = Label(root, text="a1:", padx=5, pady=5, bg='#220203', fg='white')
    a1_label_inv.grid(row=1, column=2, sticky=W)
    a1_entry_inv = Entry(root, width=10)
    a1_entry_inv.grid(row=1, column=3, padx=5, pady=5)

    a2_label_inv = Label(root, text="a2:", padx=5, pady=5, bg='#380506', fg='white')
    a2_label_inv.grid(row=2, column=2, sticky=W)
    a2_entry_inv = Entry(root, width=10)
    a2_entry_inv.grid(row=2, column=3, padx=5, pady=5)

    a3_label_inv = Label(root, text="a3:", padx=5, pady=5, bg='#540f0d', fg='white')
    a3_label_inv.grid(row=3, column=2, sticky=W)
    a3_entry_inv = Entry(root, width=10)
    a3_entry_inv.grid(row=3, column=3, padx=5, pady=5)

    # Create entry fields for position vector components
    X_label = Label(root, text="X:", padx=5, pady=5, bg='#6b0500', fg='white')
    X_label.grid(row=4, column=2, sticky=W)
    X_entry = Entry(root, width=10)
    X_entry.grid(row=4, column=3, padx=5, pady=5)

    Y_label = Label(root, text="Y:", padx=5, pady=5, bg='#87080a', fg='white')
    Y_label.grid(row=5, column=2, sticky=W)
    Y_entry = Entry(root, width=10)
    Y_entry.grid(row=5, column=3, padx=5, pady=5)

    Z_label = Label(root, text="Z:", padx=5, pady=5, bg='#980b06', fg='white')
    Z_label.grid(row=6, column=2, sticky=W)
    Z_entry = Entry(root, width=10)
    Z_entry.grid(row=6, column=3, padx=5, pady=5)

    # Create output fields for joint variables
    T1_label = Label(root, text="T1:", padx=5, pady=5, bg='#ae120a')
    T1_label.grid(row=7, column=2, sticky=W)
    T1_output = Entry(root, width=10, state='readonly')
    T1_output.grid(row=7, column=3, padx=5, pady=5)

    T2_label = Label(root, text="T2:", padx=5, pady=5, bg='#c02a2a')
    T2_label.grid(row=8, column=2, sticky=W)
    T2_output = Entry(root, width=10, state='readonly')
    T2_output.grid(row=8, column=3, padx=5, pady=5)

    T3_label = Label(root, text="T3:", padx=5, pady=5, bg='#d04346')
    T3_label.grid(row=9, column=2, sticky=W)
    T3_output = Entry(root, width=10, state='readonly')
    T3_output.grid(row=9, column=3, padx=5, pady=5)

    # Create two buttons
    calculate_btn_inv = Button(root, text="Calculate", command=calculate_inverse)
    calculate_btn_inv.grid(row=10, column=2, padx=5, pady=5)

    reset_btn_inv = Button(root, text="Reset", bg='#AE2012', command=reset_field2)
    reset_btn_inv.grid(row=10, column=3, padx=5, pady=5)


def calculate_forward():
    try:
        # Get values from entry fields
        a1 = float(a1_entry.get())/100
        a2 = float(a2_entry.get())/100
        a3 = float(a3_entry.get())/100
        T1 = float(T1_entry.get())
        T2 = float(T2_entry.get())
        T3 = float(T3_entry.get())

        # Convert joint angles to radians
        T1 = (T1 / 180.0) * np.pi
        T2 = (T2 / 180.0) * np.pi
        T3 = (T3 / 180.0) * np.pi

        # Perform forward kinematics calculations
        # Parametric Table (theta, alpha, r, d)
        PT = [[T1, (90.0 / 180.0) * np.pi, 0, a1],
              [T2, (0.0 / 180.0) * np.pi, a2, 0],
              [T3, (0.0 / 180.0) * np.pi, a3, 0]]

        # Homogeneous Transformation Matrices (HTM)
        i = 0
        H0_1 = [[np.cos(PT[i][0]),-np.sin(PT[i][0])*np.cos(PT[i][1]),np.sin(PT[i][0])*np.sin(PT[i][1]),PT[i][2]*np.cos(PT[i][0])],
            [np.sin(PT[i][0]),np.cos(PT[i][0])*np.cos(PT[i][1]),-np.cos(PT[i][0])*np.sin(PT[i][1]),PT[i][2]*np.sin(PT[i][0])],
            [0,np.sin(PT[i][1]), np.cos(PT[i][1]),PT[i][3]],
            [0,0,0,1]]

        i = 1
        H1_2 = [[np.cos(PT[i][0]),-np.sin(PT[i][0])*np.cos(PT[i][1]),np.sin(PT[i][0])*np.sin(PT[i][1]),PT[i][2]*np.cos(PT[i][0])],
            [np.sin(PT[i][0]),np.cos(PT[i][0])*np.cos(PT[i][1]),-np.cos(PT[i][0])*np.sin(PT[i][1]),PT[i][2]*np.sin(PT[i][0])],
            [0,np.sin(PT[i][1]), np.cos(PT[i][1]),PT[i][3]],
            [0,0,0,1]]

        i = 2
        H2_3 = [[np.cos(PT[i][0]),-np.sin(PT[i][0])*np.cos(PT[i][1]),np.sin(PT[i][0])*np.sin(PT[i][1]),PT[i][2]*np.cos(PT[i][0])],
            [np.sin(PT[i][0]),np.cos(PT[i][0])*np.cos(PT[i][1]),-np.cos(PT[i][0])*np.sin(PT[i][1]),PT[i][2]*np.sin(PT[i][0])],
            [0,np.sin(PT[i][1]), np.cos(PT[i][1]),PT[i][3]],
            [0,0,0,1]]

        H0_1 = np.matrix (H0_1)
        H1_2 = np.matrix (H1_2)
        H2_3 = np.matrix (H2_3)

        H0_2 = np.dot(H0_1,H1_2)
        H0_3 = np.dot(H0_2,H2_3)

        X0_3 = H0_3[0, 3]
        Y0_3 = H0_3[1, 3]
        Z0_3 = H0_3[2, 3]

        # Display the results in the output fields
        X_output.config(state='normal')
        X_output.delete(0, END)
        X_output.insert(0, np.around(X0_3*100,3))
        X_output.config(state='readonly')

        Y_output.config(state='normal')
        Y_output.delete(0, END)
        Y_output.insert(0, np.around(Y0_3*100,3))
        Y_output.config(state='readonly')

        Z_output.config(state='normal')
        Z_output.delete(0, END)
        Z_output.insert(0, np.around(Z0_3*100,3))
        Z_output.config(state='readonly')

    except ValueError:
        # Handle error if invalid input is provided
        messagebox.showerror("Error", "Please enter valid numbers for all input fields.")

#Create links
#[robot_value]=DHRobot([RevoluteDH(d,r,alpha,offset)])

    Articulated_Calculator=DHRobot([
        RevoluteDH(a1,0,(90.0/180.0)*np.pi,(0.0/180.0)*np.pi,qlim=[-np.pi/2,np.pi/2]),
        RevoluteDH(0,a2,(0.0/180.0)*np.pi,(0.0/180.0)*np.pi,qlim=[-np.pi/2,np.pi/2]),
        RevoluteDH(0,a3,(0.0/180.0)*np.pi,(0.0/180.0)*np.pi,qlim=[-np.pi/2,np.pi/2])],name='Articulated')

#plot joints
    q1 = np.array([T1,T2,T3])

#plot scale
    x1=-0.5
    x2=0.5
    y1=-0.5
    y2=0.5
    z1=0.0
    z2=0.5

#Plot Command

    Articulated_Calculator.plot(q1,limits=[x1,x2,y1,y2,z1,z2])

def calculate_inverse():
    try:
        # Get values from entry fields
        a1 = float(a1_entry_inv.get())
        a2 = float(a2_entry_inv.get())
        a3 = float(a3_entry_inv.get())
        x0_3 = float(X_entry.get())
        y0_3 = float(Y_entry.get())
        z0_3 = float(Z_entry.get())

        # Perform inverse kinematics calculations
        if x0_3 == 0:
            theta1 = np.pi / 2 if y0_3 > 0 else -np.pi / 2
        else:
            theta1 = np.arctan(y0_3 / x0_3)  # Sol1

        r1 = np.sqrt(y0_3**2 + x0_3**2)  # Sol2
        r2 = z0_3 - a1  # Sol3

        if r1 == 0:
            phi1 = np.pi / 2 if r2 > 0 else - np.pi / 2
        else:
            phi1 = np.arctan(r2 / r1)  # Sol4

        r3 = np.sqrt(r2**2 + r1**2)  # Sol5

        phi2 = np.arccos(np.clip((a3**2 - a2**2 - r3**2) / (-2 * a2 * r3), -1, 1))  # Sol6

        theta2 = phi1 + phi2# Sol7

        phi3 = np.arccos(np.clip((r3**2 - a2**2 - a3**2) / (-2 * a2 * a3), -1, 1))  # Sol8

        theta3 = phi3 - np.pi# Sol9

        # Convert angles from radians to degrees
        theta1_deg = (np.around(theta1*180/np.pi,3))
        theta2_deg = (np.around(theta2*180/np.pi,3))
        theta3_deg = (np.around(theta3*180/np.pi,3))

        # Display the results in the output fields
        T1_output.config(state='normal')
        T1_output.delete(0, END)
        T1_output.insert(0, str(theta1_deg))
        T1_output.config(state='readonly')

        T2_output.config(state='normal')
        T2_output.delete(0, END)
        T2_output.insert(0, str(theta2_deg))
        T2_output.config(state='readonly')

        T3_output.config(state='normal')
        T3_output.delete(0, END)
        T3_output.insert(0, str(theta3_deg))
        T3_output.config(state='readonly')

    except ValueError:
        # Handle error if invalid input is provided
        messagebox.showerror("Error", "Please enter valid numbers for all input fields.")

#Create links
#[robot_value]=DHRobot([RevoluteDH(d,r,alpha,offset)])
        
    Articulated_Calculator=DHRobot([
        RevoluteDH(a1/100,0,(90.0/180.0)*np.pi,(0.0/180.0)*np.pi,qlim=[-np.pi/2,np.pi/2]),
        RevoluteDH(0,a2/100,(0.0/180.0)*np.pi,(0.0/180.0)*np.pi,qlim=[-np.pi/2,np.pi/2]),
        RevoluteDH(0,a3/100,(0.0/180.0)*np.pi,(0.0/180.0)*np.pi,qlim=[-np.pi/2,np.pi/2])],name='Articulated')

#plot joints
    q1 = np.array([theta1,theta2,theta3])

    #plot scale
    x1=-0.5
    x2=0.5
    y1=-0.5
    y2=0.5
    z1=0.0
    z2=0.5

    #Plot Command
    Articulated_Calculator.plot(q1,limits=[x1,x2,y1,y2,z1,z2])


def reset_field1():
    # Clear all entry fields and output fields
    a1_entry.delete(0, END)
    a2_entry.delete(0, END)
    a3_entry.delete(0, END)
    T1_entry.delete(0, END)
    T2_entry.delete(0, END)
    T3_entry.delete(0, END)
    X_output.config(state='normal')
    X_output.delete(0, END)
    X_output.config(state='readonly')
    Y_output.config(state='normal')
    Y_output.delete(0, END)
    Y_output.config(state='readonly')
    Z_output.config(state='normal')
    Z_output.delete(0, END)
    Z_output.config(state='readonly')

def reset_field2():
    a1_entry_inv.delete(0, END)
    a2_entry_inv.delete(0, END)
    a3_entry_inv.delete(0, END)
    X_entry.delete(0, END)
    Y_entry.delete(0, END)
    Z_entry.delete(0, END)
    T1_output.config(state='normal')
    T1_output.delete(0, END)
    T1_output.config(state='readonly')
    T2_output.config(state='normal')
    T2_output.delete(0, END)
    T2_output.config(state='readonly')
    T3_output.config(state='normal')
    T3_output.delete(0, END)
    T3_output.config(state='readonly')

# Create buttons for Forward and Inverse Kinematics
forward_btn = Button(root, text="Forward Kinematics", bg='#0A9396', command=Forward_Kinematics)
forward_btn.grid(row=0, column=0, padx=5, pady=5)

inverse_btn = Button(root, text="Inverse Kinematics", bg='#9B2226',command=Inverse_Kinematics)
inverse_btn.grid(row=0, column=2, padx=5, pady=5)

# Run the main event loop
root.mainloop()
